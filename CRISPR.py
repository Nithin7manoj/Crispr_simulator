# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1idCVpq7vglGQT9Rg7YxpANv9RdeGPrID
"""

import random
import math
import matplotlib.pyplot as plt
import pandas as pd

import random, math

class CRISPR:
  def __init__(self, cas_type="SpCas9"):
    self.cas_type = cas_type
    self.weights = {"w0": 1.2, "w1": -0.5, "w2": -0.3, "w3": 0.7}
    self.repair_probs = {"frameshift": 0.4, "small_del": 0.3, "ins_1bp": 0.05, "inframe": 0.25}
    self.unmodelled_risk = 0.01

  def extract_features(self, guide_seq, target_seq):
    mismatches = 0
    weighted_penalty = 0
    for i in range(len(guide_seq)):
      if guide_seq[i] != target_seq[i]:
        mismatches += 1
        if i >= (len(guide_seq) - 6):
          weighted_penalty += 2
        else:
          weighted_penalty += 1
    gc_content = (guide_seq.count('G') + guide_seq.count('C')) / len(guide_seq)
    return {"mismatches": mismatches, "weighted_penalty": weighted_penalty, "gc_content": gc_content}

  def cleavage_probability(self, features):
    z = self.weights["w0"] + (self.weights["w1"] * features["mismatches"]) + (self.weights["w2"] * features["weighted_penalty"]) + (self.weights["w3"] * features["gc_content"])
    p_cleave = 1 / (1 + math.exp(-z))
    return p_cleave

  def repair_outcome(self):
    outcome_list = ["frameshift", "small_del", "inframe", "ins_1bp"]
    probab = [0.4, 0.3, 0.25, 0.05]
    chosen_outcome = random.choices(outcome_list, weights=probab, k=1)[0]
    return chosen_outcome

  def find_offtargets(self, guide_seq, genome_seq, max_mismatches=3):
    offtargets = []
    for i in range(len(genome_seq) - len(guide_seq)):
      window = genome_seq[i:i+len(guide_seq)]
      mismatches = 0
      for j in range(len(guide_seq)):
        if guide_seq[j] != window[j]:
          mismatches += 1
      if mismatches <= max_mismatches:
        features = self.extract_features(guide_seq, window)
        p_cut_site = self.cleavage_probability(features)
        if random.random() < p_cut_site:
          offtargets.append({"position": i, "sequence": window, "mismatches": mismatches, "cut_prob": p_cut_site})
    return offtargets

  def total_offtarget_risk(self, offtargets):
    risk_product = 1
    for site in offtargets:
      risk_product *= (1 - site["cut_prob"])
    total_risk = 1 - risk_product
    return total_risk

  def run(self, guide_seq, genome_seq):
    features = self.extract_features(guide_seq, genome_seq[:len(guide_seq)])
    p_cleave = self.cleavage_probability(features)
    outcome = self.repair_outcome()
    offtargets = self.find_offtargets(guide_seq, genome_seq)
    total_risk = self.total_offtarget_risk(offtargets)
    return {"p_cleave": p_cleave, "repair_outcome": outcome, "offtargets": offtargets, "total_offtarget_risk": total_risk}